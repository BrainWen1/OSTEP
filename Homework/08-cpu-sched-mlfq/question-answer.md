1. `./mlfq.py -j 2 -n 2 -m 20 -c`
    `./mlfq.py -j 2 -n 2 -m 20 -s 1 -c`
    `./mlfq.py -j 2 -n 2 -m 20 -s 2 -c`
    `./mlfq.py -j 2 -n 2 -m 20 -s 3 -c`
    `./mlfq.py -j 2 -n 2 -m 20 -s 666 -c`
    `./mlfq.py -j 2 -n 2 -m 20 -s 888  -c`
    `./mlfq.py -j 2 -n 2 -m 20 -s 6 -c`

2. 模拟
    - 实例1：单个长工作
        `./mlfq -j 1 -n 3 -m 50 -c`
    - 实例2：一个长工作，一个短工作
        `./mlfq -l 0,50,0:20,20,0 -c`
    - 实例3：混合IO密集型和CPU密集型
        `./mlfq.py -l 0,20,100:0,10,1 -S -c`
    - 实例4：优先级提升解决饿死问题
        - 不采用：`./mlfq.py -l 0,50,100:0,5,1:0,5,1 -B 0 -c`
        - 采用：  `./mlfq.py -l 0,50,100:0,5,1:0,5,1 -B 50 -c`
    - 实例5：愚弄反制：累计队列时间配额
        - 不采用：`./mlfq.py -l 0,20,1 -A 1 -S -c`
        - 采用：  `./mlfq.py -l 0,20,1 -A 1 -c`
    - 实例6：优先级越低，时间片越长
        `./mlfq.py -l 0,200,10 -Q 20,50,100 -c`

3. 要像想轮转调度那样运行，只需要分配一个队列，并且固定量子长度为一个值，也即RR的量子长度，并且在一个进程的IO结束后不让它插队，而是排到队尾（不加 -I）。
    `./mlfq.py -n 1 -q 10 -l 0,30,10:0,30,10 -c`

4. `./mlfq.py -n 2 -q 1 -S -i 1 -l 0,1000,1:0,1000,10000 -c`

5. 核心是：提升越频繁，长作业的 CPU 占比越高
    只要将优先级提升的频率设置为每 200ms 一次（即-B 200），就能保证长作业在每个周期内至少获得 10ms 的 CPU 时间，占比 ≥5%。

6. 添加 -I 选项会让刚刚完成IO的进程立即提升到当前队列的队首，即实现插队。

1. 种子为1 2 3：
    - `./lottery.py -j 3 -m 10 -s 1 -c`
        12
    - `./lottery.py -j 3 -m 10 -s 2 -c`
        23
    - `./lottery.py -j 3 -m 10 -s 3 -c`
        11

2. `./lottery.py -l 10:1,10:100`
    - 在作业 0 结束之前，作业 1 大概率不会被运行，即使运气好运行了，也仅会获得极短的 CPU 时间（通常不超过 1 个时间片），几乎可以忽略。
        - 低彩票数的作业会出现 **“饥饿” 现象**：长期无法获得 CPU 资源；
        - 违背 “比例份额” 的设计预期：理论上的 “概率公平” 在实际中会退化为 “高彩票作业垄断资源”，失去调度的公平性。

3. 种子1 2 3：
   1. `./lottery.py -l 100:100,100:100 -s 1 -c`
        - 作业 1 在时间 196 结束，作业 0 在时间 200 结束
   2. `./lottery.py -l 100:100,100:100 -s 1 -c`
        - 作业 1 在时间 190 结束，作业 0 在时间 200 结束 
   3. `./lottery.py -l 100:100,100:100 -s 1 -c`
        - 作业 0 在时间 196 结束，作业 1 在时间 200 结束
   - 这种场景下彩票调度的不公平性极低，仅体现为概率性的小幅波动，实际 CPU 占比接近理论彩票占比，符合 “比例份额调度” 的设计预期。

4. 增加量子长度：
    - `./lottery.py -l 100:100,100:100 -q 10 -s 1 -c`
    - 量子规模越大，抽选彩票的次数越少，实际 CPU 分配偏离 “50% 理论占比” 的概率越高，两个作业的完成时间差异会显著增大，调度的不公平性也随之提升。
    - 但是如果相对地提高抽取次数，就可以让彩票调度的实际 CPU 占比重新逼近50%理论值。

